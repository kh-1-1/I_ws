# 路径跟踪示例

<cite>
**本文档中引用的文件**  
- [path_track.py](file://RDA-planner/example/path_track/path_track.py)
- [path_track.yaml](file://RDA-planner/example/path_track/path_track.yaml)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py)
- [rda_solver.py](file://RDA-planner/RDA_planner/rda_solver.py)
</cite>

## 目录
1. [项目结构](#项目结构)
2. [核心组件](#核心组件)
3. [架构概述](#架构概述)
4. [详细组件分析](#详细组件分析)
5. [依赖分析](#依赖分析)
6. [性能考虑](#性能考虑)
7. [故障排除指南](#故障排除指南)
8. [结论](#结论)

## 项目结构

RDA-planner项目中的路径跟踪示例位于`RDA-planner/example/path_track`目录下，包含多个针对不同机器人动力学模型的实现文件。该目录包含用于阿克曼转向、差速驱动和全向移动机器人的路径跟踪脚本及其相应的配置文件。

```mermaid
graph TD
A[path_track] --> B[path_track.py]
A --> C[path_track.yaml]
A --> D[path_track_diff.py]
A --> E[path_track_diff.yaml]
A --> F[path_track_omni.py]
A --> G[path_track_omni.yaml]
H[RDA_planner] --> I[mpc.py]
H --> J[rda_solver.py]
```

**图示来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py)

**章节来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py)
- [path_track.yaml](file://RDA-planner/example/path_track/path_track.yaml)

## 核心组件

路径跟踪示例的核心组件包括`path_track.py`脚本，该脚本利用RDA求解器生成平滑且符合动力学约束的跟踪轨迹。MPC控制器通过预定义路径作为参考轨迹输入，并结合环境信息进行实时控制。

**章节来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py#L1-L46)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py#L1-L569)

## 架构概述

系统架构基于模型预测控制（MPC）框架，利用RDA求解器处理路径跟踪问题。控制器接收当前机器人状态和参考路径，通过优化算法计算最优控制输入，确保机器人能够平滑地跟踪预定义路径。

```mermaid
graph TB
subgraph "用户层"
A[path_track.py]
end
subgraph "控制层"
B[MPC控制器]
C[RDA求解器]
end
subgraph "环境层"
D[仿真环境]
E[障碍物信息]
end
A --> B
B --> C
D --> B
E --> B
B --> D
```

**图示来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py#L1-L46)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py#L1-L569)

## 详细组件分析

### MPC控制器分析

MPC控制器负责将预定义路径作为参考轨迹输入，并利用RDA求解器生成平滑且符合动力学约束的跟踪轨迹。控制器通过迭代求解优化问题，实时调整控制输入以最小化跟踪误差。

#### 类图
```mermaid
classDiagram
class MPC {
+car_tuple : tuple
+receding : int
+dt : float
+cur_vel_array : array
+state : array
+ref_path : list
+rda : RDA_solver
+enable_reverse : bool
+obstacle_order : bool
+goal_index_threshold : int
+__init__(car_tuple, ref_path, receding, sample_time, iter_num, enable_reverse, rda_obstacle, obstacle_order, max_edge_num, max_obs_num, process_num, accelerated, time_print, goal_index_threshold, **kwargs)
+control(state, ref_speed, obstacle_list, **kwargs)
+convert_rda_obstacle(obstacle_list, state, obstacle_order)
+rda_obs_distance(rda_obs)
+update_ref_path(ref_path)
+update_parameter(**kwargs)
+split_path(ref_path)
+pre_process(state, ref_path, cur_index, ref_speed, **kwargs)
+motion_predict_model_acker(car_state, vel, wheel_base, sample_time)
+motion_predict_model_diff(robot_state, vel, sample_time)
+motion_predict_model_omni(robot_state, vel, sample_time)
+closest_point(state, ref_path, start_ind, threshold, ind_range, **kwargs)
+inter_point(traj_point, ref_path, cur_ind, length)
+range_cir_seg(circle, r, segment)
+distance(point1, point2)
+wraptopi(radian)
+convert_inequal_circle(center, radius, velocity)
+convert_inequal_polygon(vertex, velocity)
+gen_inequal_global(vertex)
+cross_product(o, a, b)
+is_convex_and_ordered(points)
+get_adjust_parameters()
+no_ref_path()
+reset()
}
class RDA_solver {
+T : int
+car_tuple : tuple
+L : float
+max_speed : array
+max_obs_num : int
+max_edge_num : int
+dynamics : str
+iter_num : int
+dt : float
+acce_bound : array
+iter_threshold : float
+accelerated : bool
+process_num : int
+time_print : bool
+indep_s : Variable
+indep_u : Variable
+indep_dis : Variable
+indep_rot_list : list
+indep_lam_list : list
+indep_mu_list : list
+indep_z_list : list
+indep_Im_array_su : Variable
+indep_Im_array_LamMuZ : list
+indep_Hm_array_su : Variable
+indep_Hm_array_LamMuZ : list
+para_ref_s : Parameter
+para_ref_speed : Parameter
+para_s : Parameter
+para_u : Parameter
+para_dis : Parameter
+para_rot_list : list
+para_drot_list : list
+para_drot_phi_list : list
+para_A_list : list
+para_B_list : list
+para_C_list : list
+para_lam_list : list
+para_mu_list : list
+para_z_list : list
+para_xi_list : list
+para_zeta_list : list
+para_obstacle_list : list
+para_obsA_lam_list : list
+para_obsb_lam_list : list
+para_obsA_rot_list : list
+para_obsA_trans_list : list
+para_slack_gain : Parameter
+para_max_sd : Parameter
+para_min_sd : Parameter
+ro1 : Parameter
+ro2 : Parameter
+__init__(receding, car_tuple, max_edge_num, max_obs_num, iter_num, step_time, iter_threshold, process_num, accelerated, time_print, **kwargs)
+definition(**kwargs)
+state_variable_define()
+dual_variable_define()
+combine_variable_define()
+state_parameter_define()
+dual_parameter_define()
+obstacle_parameter_define()
+combine_parameter_define()
+adjust_parameter_define(**kwargs)
+construct_problem(**kwargs)
+construct_mp_problem(process_num, **kwargs)
+construct_su_prob(**kwargs)
+construct_LamMuZ_prob(**kwargs)
+init_prob_LamMuZ(kwargs)
+construct_LamMuZ_prob_parallel(para_xi_list, para_zeta_list, para_s, para_rot_list, para_dis, para_obstacle_list, para_obsA_rot_list, para_obsA_trans_list, **kwargs)
+nav_cost_cons(ws, wu)
+update_su_cost_cons(slack_gain, ro1, ro2)
+LamMuZ_cost_cons(indep_lam, indep_mu, indep_z, indep_Im_lamMuZ, indep_Hm_lamMuZ, para_s, para_rot_list, para_xi, para_dis, para_zeta, para_obs, para_obsA_rot, para_obsA_trans, receding, ro1, ro2)
+assign_adjust_parameter(**kwargs)
+assign_state_parameter(nom_s, nom_u, nom_dis)
+assign_state_parameter_parallel(input)
+assign_dual_parameter(LamMuZ_list)
+assign_obstacle_parameter(obstacle_list)
+assign_combine_parameter_lamobs()
+assign_combine_parameter_stateobs()
+iterative_solve(nom_s, nom_u, ref_states, ref_speed, obstacle_list, **kwargs)
+rda_solver()
+update_zeta()
+update_xi()
+su_prob_solve()
+LamMuZ_prob_solve()
+solve_parallel(input)
+solve_direct(input)
}
MPC --> RDA_solver : "使用"
```

**图示来源**
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py#L1-L569)
- [rda_solver.py](file://RDA-planner/RDA_planner/rda_solver.py#L1-L799)

#### 控制流程
```mermaid
sequenceDiagram
participant 脚本 as path_track.py
participant MPC as MPC控制器
participant RDA as RDA求解器
participant 环境 as 仿真环境
脚本->>MPC : 初始化MPC控制器
脚本->>环境 : 创建仿真环境
环境->>脚本 : 返回机器人信息
脚本->>MPC : 设置参考路径
loop 每个控制周期
脚本->>环境 : 获取当前状态
脚本->>环境 : 获取障碍物信息
脚本->>MPC : 调用control方法
MPC->>RDA : 调用iterative_solve
RDA->>RDA : 执行优化求解
RDA-->>MPC : 返回最优控制输入
MPC-->>脚本 : 返回最优速度
脚本->>环境 : 执行控制输入
脚本->>环境 : 渲染环境
end
脚本->>环境 : 结束仿真
```

**图示来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py#L1-L46)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py#L1-L569)

**章节来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py#L1-L46)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py#L1-L569)

## 依赖分析

路径跟踪示例依赖于RDA-planner库中的MPC和RDA求解器组件，以及irsim仿真环境。这些组件共同协作，实现高效的路径跟踪功能。

```mermaid
graph TD
A[path_track.py] --> B[irsim]
A --> C[RDA_planner.mpc]
C --> D[RDA_planner.rda_solver]
D --> E[cvxpy]
D --> F[pathos]
D --> G[numpy]
A --> H[numpy]
```

**图示来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py#L1-L46)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py#L1-L569)
- [rda_solver.py](file://RDA-planner/RDA_planner/rda_solver.py#L1-L799)

**章节来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py#L1-L46)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py#L1-L569)
- [rda_solver.py](file://RDA-planner/RDA_planner/rda_solver.py#L1-L799)

## 性能考虑

RDA-planner通过并行计算和高效的优化算法确保实时性能。MPC控制器的迭代次数和预测时域可以根据具体应用场景进行调整，以平衡计算复杂度和控制精度。

## 故障排除指南

在使用路径跟踪示例时，如果遇到问题，可以检查以下几点：
- 确保参考路径文件存在且格式正确
- 检查机器人动力学参数设置是否合理
- 验证障碍物信息是否正确传递给控制器
- 调整MPC控制器的参数以优化跟踪性能

**章节来源**
- [path_track.py](file://RDA-planner/example/path_track/path_track.py#L1-L46)
- [mpc.py](file://RDA-planner/RDA_planner/mpc.py#L1-L569)

## 结论

RDA-planner的路径跟踪示例展示了如何利用MPC框架和RDA求解器实现高效、平滑的路径跟踪。通过合理配置参数和优化算法，可以在复杂环境中实现精确的机器人导航。